#!/usr/bin/env bash
# bin/compile <build-dir> <cache-dir> <env-dir>
# $HOME: /app

set -e

echo 'BUN-BUILDPACK - v1.0.0'

BUILD_DIR=${1:-.}
CACHE_DIR=${2:-}
ENV_DIR=${3:-}

HEROKU_DIR=$BUILD_DIR/.heroku
BIN_DIR=$HEROKU_DIR/bin

# Define variables
BP_CLEAN=${CLEAN:-true}
BP_NODE=${NODE:-true}
BP_NODE_VERSION=${NODE_VERSION:-20.9.0}

# New variables for custom commands
BP_INSTALL_COMMAND=${INSTALL_COMMAND:-"bun install"}
BP_BUILD_COMMAND=${BUILD_COMMAND:-"bun run build"}
BP_START_COMMAND=${START_COMMAND:-"bun run start"}
BP_APP_DIR=${APP_DIR:-}
BP_RUNTIME_DIR=${RUNTIME_DIR:-dist}
BP_GENERATE_RUNTIME_PKG=${GENERATE_RUNTIME_PKG:-true}
BP_PROD_INSTALL=${PROD_INSTALL:-true}

# Function to export env vars from ENV_DIR
export_env_dir() {
  env_dir=$1
  acceptlist_regex=${2:-''}
  denylist_regex=${3:-'^(PATH|GIT_DIR|CPATH|CPPATH|LD_PRELOAD|LIBRARY_PATH)$'}
  if [ -d "$env_dir" ]; then
    for e in $(ls $env_dir); do
      echo "$e" | grep -E "$acceptlist_regex" | grep -qvE "$denylist_regex" &&
      export "$e=$(cat $env_dir/$e)"
    done
  fi
}

# Export Heroku Config Vars
export_env_dir $ENV_DIR

# To enable the local source build cache path, copy the files and match the build path with the startup path.
cp -rT $BUILD_DIR $HOME
cd $HOME

if [ -f runtime.bun.txt ]
then
  INSTALL_VERSION_OPTION="-s bun-$(cat runtime.bun.txt)"
elif [ -f runtime.txt ]
then
  INSTALL_VERSION_OPTION="-s bun-$(cat runtime.txt)"
fi
echo $INSTALL_VERSION_OPTION

# Install Node.js using prebuilt binaries if BP_NODE is true
if $BP_NODE; then
  echo "NODE config var is true, installing Node.js..."
  NODE_DISTRO="node-v$BP_NODE_VERSION-linux-x64"
  NODE_TAR="$NODE_DISTRO.tar.xz"
  NODE_URL="https://nodejs.org/dist/v$BP_NODE_VERSION/$NODE_TAR"

  curl -O $NODE_URL
  tar -xf $NODE_TAR || { echo "Error extracting Node.js tarball"; exit 1; }
  mkdir -p $HEROKU_DIR/node
  mv $NODE_DISTRO/* $HEROKU_DIR/node
  rm -rf $NODE_TAR $NODE_DISTRO

  # Add Node.js to PATH
  export PATH="$HEROKU_DIR/node/bin:$PATH"
else
  echo "NODE config var is not set to true, skipping Node.js installation..."
fi

# Install Bun
export BUN_INSTALL=$BUILD_DIR/.heroku
export BUN_DIR=$BUILD_DIR/.heroku/cache
curl -fsSL https://bun.sh/install | bash $INSTALL_VERSION_OPTION
export PATH="$BUN_INSTALL/bin:$PATH"

# Set environment variables
PROFILE_PATH="$BUILD_DIR/.profile.d/bun.sh"
mkdir -p $(dirname $PROFILE_PATH)
echo 'export PATH="$HOME/.heroku/node/bin:$PATH"' >> $PROFILE_PATH
echo 'export PATH="$HOME/.heroku/bin:$PATH"' >> $PROFILE_PATH
echo 'export BUN_DIR="$HOME/.heroku/cache"' >> $PROFILE_PATH

set +e

# Resolve execution directory (monorepo app dir if provided)
if [ -n "$BP_APP_DIR" ] && [ -d "$BUILD_DIR/$BP_APP_DIR" ]; then
  EXEC_DIR="$BUILD_DIR/$BP_APP_DIR"
  echo "Using APP_DIR: $BP_APP_DIR"
else
  EXEC_DIR="$BUILD_DIR"
fi

# Determine runtime directory inside the app
if [ -d "$EXEC_DIR/$BP_RUNTIME_DIR" ]; then
  RUNTIME_DIR_CANDIDATE="$BP_RUNTIME_DIR"
elif [ -d "$EXEC_DIR/dist" ]; then
  RUNTIME_DIR_CANDIDATE="dist"
elif [ -d "$EXEC_DIR/build" ]; then
  RUNTIME_DIR_CANDIDATE="build"
else
  RUNTIME_DIR_CANDIDATE="."
fi
RUNTIME_PATH="$EXEC_DIR/$RUNTIME_DIR_CANDIDATE"
echo "Runtime directory resolved to: $RUNTIME_PATH"
export EXEC_DIR
export RUNTIME_PATH

# Download dependencies
if [ -f "$EXEC_DIR/package.json" ]; then
  echo "Installing dependencies..."
  cd $EXEC_DIR
  eval $BP_INSTALL_COMMAND

  echo "Building App"
  eval $BP_BUILD_COMMAND

  # Generate minimal package.json in runtime dir (excluding workspace:* deps) if requested
  if [ "$BP_GENERATE_RUNTIME_PKG" = true ]; then
    if [ ! -f "$RUNTIME_PATH/package.json" ] && [ -f "$EXEC_DIR/package.json" ]; then
      echo "Generating runtime package.json at $RUNTIME_PATH"
      bun -e '
        import { readFileSync, writeFileSync } from "node:fs"
        const execDir = process.env.EXEC_DIR
        const runtimePath = process.env.RUNTIME_PATH
        const appPkg = JSON.parse(readFileSync(execDir + "/package.json", "utf8"))
        const filterDeps = (deps = {}) => Object.fromEntries(
          Object.entries(deps).filter(([_, v]) => typeof v === "string" && !v.startsWith("workspace:"))
        )
        const runtimePkg = {
          name: (appPkg.name || "app") + "-runtime",
          private: true,
          type: appPkg.type,
          dependencies: filterDeps(appPkg.dependencies || {})
        }
        if (Object.keys(runtimePkg.dependencies).length === 0) {
          // Ensure object exists for bun install
          runtimePkg.dependencies = {}
        }
        writeFileSync(runtimePath + "/package.json", JSON.stringify(runtimePkg, null, 2))
      '
    else
      echo "Runtime package.json already exists or missing app package.json; skipping generation"
    fi
  fi

  # Install only production dependencies in the runtime directory
  if [ "$BP_PROD_INSTALL" = true ]; then
    if [ -f "$RUNTIME_PATH/package.json" ]; then
      echo "Installing production dependencies in runtime dir: $RUNTIME_PATH"
      cd "$RUNTIME_PATH"
      bun install --production
      cd "$EXEC_DIR"
    else
      echo "No runtime package.json found at $RUNTIME_PATH; skipping production install"
    fi
  fi

  # Conditional cleanup
  if $BP_CLEAN; then
    echo "CLEAN config var is true, cleaning up unnecessary files..."
    # Remove root node_modules only; keep runtime deps for app start
    rm -rf $BUILD_DIR/node_modules
    if [ -n "$BP_APP_DIR" ]; then
      rm -rf $EXEC_DIR/node_modules
    fi
    rm -rf $BUILD_DIR/tmp
    rm -rf $BUILD_DIR/.cache
    rm -rf $HEROKU_DIR/install/cache
    rm -rf $HEROKU_DIR/install
    # Add any other directories you don't need in your final slug
  else
    echo "CLEAN config var is not set to true, skipping cleanup..."
  fi
fi

# Add start command to .profile.d
echo "Added bun environment to .profile.d"
