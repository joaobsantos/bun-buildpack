#!/usr/bin/env bash
# NewsoftDS Monorepo Buildpack for Heroku
# Ultra-simple but with full functionality
#
set -e

# ðŸŽ¨ Pretty logging functions
log_header() { echo ""; echo "ðŸš€ $1"; echo ""; }
log_step() { echo "   ðŸ“¦ $1"; }
log_success() { echo "   âœ… $1"; }
log_info() { echo "   â„¹ï¸  $1"; }
log_error() { echo "   âŒ $1"; }

# ðŸ“‚ Directory setup
BUILD_DIR=${1:-.}
CACHE_DIR=${2:-}
ENV_DIR=${3:-}

log_header "NewsoftDS Monorepo Buildpack v3.0 (Simple + Complete)"

# ðŸ”§ Export environment variables from Heroku
export_env_dir() {
  if [ -d "$1" ]; then
    for e in $(ls $1); do
      case $e in
        PATH|GIT_DIR|CPATH|CPPATH|LD_PRELOAD|LIBRARY_PATH) ;;
        *) export "$e=$(cat $1/$e)" ;;
      esac
    done
  fi
}

export_env_dir $ENV_DIR

# âš™ï¸ Configuration with defaults
BP_NODE=${BP_NODE:-"false"}
BP_NODE_VERSION=${BP_NODE_VERSION:-"22.11.0"}
BP_BUN_VERSION=${BP_BUN_VERSION:-"latest"}
BP_INSTALL=${BP_INSTALL:-"bun install"}
BP_CLEAN=${BP_CLEAN:-"true"}

# Helper function to check boolean values
is_true() {
  case "$1" in
    true|TRUE|True|1|yes|YES|Yes|on|ON|On) return 0 ;;
    *) return 1 ;;
  esac
}

# â— Validate required environment variables
VALIDATION_FAILED=false

if [ -z "$BP_BUILD" ]; then
  log_error "BP_BUILD environment variable is required!"
  log_info "Set it with: heroku config:set BP_BUILD=@newsoftds/api-gateway-server"
  log_info "Or: heroku config:set BP_BUILD=apis/servers/api-gateway-server"
  log_info "Available projects:"
  find . -name "package.json" -path "*/servers/*" -o -path "*/packages/*" 2>/dev/null | head -5 || true
  VALIDATION_FAILED=true
fi

if [ -z "$BP_START" ]; then
  log_error "BP_START environment variable is required!"
  log_info "Set it with: heroku config:set BP_START=start"
  log_info "Can be a script name (start, build:start) or command (bun index.js)"
  log_info "Script names are resolved from the built package.json"
  VALIDATION_FAILED=true
fi

if [ "$VALIDATION_FAILED" = true ]; then
  log_header "âŒ Build Failed - Missing Required Environment Variables"
  log_info "Please set the required variables and redeploy:"
  log_info "heroku config:set BP_BUILD=your-project-or-path"
  log_info "heroku config:set BP_START='bun index.js'"
  exit 1
fi

log_info "Project to build: $BP_BUILD"
log_info "Start command: $BP_START"
if is_true "$BP_NODE"; then
  log_info "Node.js: enabled (v$BP_NODE_VERSION)"
else
  log_info "Node.js: disabled (Bun only)"
fi
log_info "Bun version: $BP_BUN_VERSION"

# ðŸ—ï¸ Setup build environment
HEROKU_DIR=$BUILD_DIR/.heroku
mkdir -p $HEROKU_DIR/bin

# Move to build directory
cd $BUILD_DIR

# ðŸ“¦ Install Node.js (optional)
if is_true "$BP_NODE"; then
  log_step "Installing Node.js v$BP_NODE_VERSION"
  NODE_DISTRO="node-v$BP_NODE_VERSION-linux-x64"
  NODE_TAR="$NODE_DISTRO.tar.xz"
  NODE_URL="https://nodejs.org/dist/v$BP_NODE_VERSION/$NODE_TAR"
  
  curl -O $NODE_URL
  tar -xf $NODE_TAR || { 
    log_error "Error extracting Node.js tarball"
    exit 1
  }
  mkdir -p $HEROKU_DIR/node
  mv $NODE_DISTRO/* $HEROKU_DIR/node
  rm -rf $NODE_TAR $NODE_DISTRO
  
  export PATH="$HEROKU_DIR/node/bin:$PATH"
  log_success "Node.js installed: $(node --version)"
else
  log_step "Skipping Node.js installation (BP_NODE=false)"
fi

# ðŸ¥¯ Install Bun
log_step "Installing Bun"

# Determine Bun version
INSTALL_VERSION_OPTION=""
if [ -f runtime.bun.txt ]; then
  INSTALL_VERSION_OPTION="-s bun-$(cat runtime.bun.txt)"
  log_info "Using Bun version from runtime.bun.txt: $(cat runtime.bun.txt)"
elif [ -f runtime.txt ]; then
  INSTALL_VERSION_OPTION="-s bun-$(cat runtime.txt)"
  log_info "Using Bun version from runtime.txt: $(cat runtime.txt)"
elif [ "$BP_BUN_VERSION" != "latest" ]; then
  INSTALL_VERSION_OPTION="-s bun-$BP_BUN_VERSION"
  log_info "Using Bun version from BP_BUN_VERSION: $BP_BUN_VERSION"
fi

export BUN_INSTALL=$BUILD_DIR/.heroku
export BUN_DIR=$BUILD_DIR/.heroku/cache
curl -fsSL https://bun.sh/install | bash $INSTALL_VERSION_OPTION
export PATH="$BUN_INSTALL/bin:$PATH"
log_success "Bun installed: $(bun --version)"

# ðŸ“‹ Setup runtime environment
PROFILE_PATH="$BUILD_DIR/.profile.d/bun.sh"
mkdir -p $(dirname $PROFILE_PATH)
if is_true "$BP_NODE"; then
  cat > $PROFILE_PATH << 'EOF'
export PATH="$HOME/.heroku/node/bin:$PATH"
export PATH="$HOME/.heroku/bin:$PATH"
export BUN_DIR="$HOME/.heroku/cache"
EOF
else
  cat > $PROFILE_PATH << 'EOF'
export PATH="$HOME/.heroku/bin:$PATH"
export BUN_DIR="$HOME/.heroku/cache"
EOF
fi

# ðŸ“¦ Install monorepo dependencies
log_step "Installing monorepo dependencies"
log_info "Running: $BP_INSTALL --ignore-scripts"

# Add --ignore-scripts to prevent postinstall database connections
if [[ "$BP_INSTALL" == *"--ignore-scripts"* ]]; then
  eval $BP_INSTALL
else
  eval "$BP_INSTALL --ignore-scripts"
fi

if [ $? -eq 0 ]; then
  log_success "Dependencies installed"
else
  log_error "Dependency installation failed"
  exit 1
fi

# ðŸ—ï¸ Build the project
log_step "Building $BP_BUILD"

# Determine project path - support both @newsoftds/name and path formats
PROJECT_PATH=""
if [[ "$BP_BUILD" == @* ]]; then
  # It's a package name, try to find it
  case $BP_BUILD in
    "@newsoftds/api-gateway-server")
      PROJECT_PATH="apis/servers/api-gateway-server"
      ;;
    "@newsoftds/api-clinic-server")
      PROJECT_PATH="apis/servers/api-clinic-server"
      ;;
    "@newsoftds/api-university-server")
      PROJECT_PATH="apis/servers/api-university-server"
      ;;
    "@newsoftds/portal-paciente")
      PROJECT_PATH="web/packages/portal-paciente"
      ;;
    *)
      # Try to auto-detect
      for project_file in $(find . -name "package.json" -not -path "./node_modules/*" 2>/dev/null); do
        project_name=$(cat "$project_file" | bun -e 'const p=JSON.parse(await Bun.stdin.text()); console.log(p.name || "")' 2>/dev/null)
        if [ "$project_name" = "$BP_BUILD" ]; then
          PROJECT_PATH=$(dirname "$project_file")
          break
        fi
      done
      ;;
  esac
else
  # It's already a path
  PROJECT_PATH="$BP_BUILD"
fi

if [ -z "$PROJECT_PATH" ] || [ ! -d "$PROJECT_PATH" ]; then
  log_error "Project not found: $BP_BUILD"
  log_info "Check that BP_BUILD is either a valid package name or path"
  exit 1
fi

log_info "Project path: $PROJECT_PATH"
cd "$PROJECT_PATH"

# Check which build script to use
if [ -f "package.json" ] && grep -q '"build:heroku"' package.json; then
  log_info "Running build:heroku script"
  bun run build:heroku
elif [ -f "package.json" ] && grep -q '"build"' package.json; then
  log_info "Running build script"
  bun run build
else
  log_error "No build script found in package.json"
  log_info "Add a 'build:heroku' or 'build' script to your package.json"
  exit 1
fi

log_success "Build completed"

# ðŸ“¦ Check if dist directory was created
if [ ! -d "dist" ]; then
  log_error "Build did not create a dist directory"
  exit 1
fi

# Move dist contents to app root
log_step "Preparing deployment"
cp -r dist/* $BUILD_DIR/
cd $BUILD_DIR

# ðŸ” Check if we have a package.json in the build output
if [ ! -f "package.json" ]; then
  log_error "No package.json found in build output"
  log_info "Your build script should generate a package.json in dist/"
  exit 1
fi

# ðŸ“¦ Install production dependencies
log_step "Installing production dependencies"
# Don't use frozen lockfile since we're generating a new package.json
bun install --production --ignore-scripts --no-frozen-lockfile
log_success "Production dependencies installed"

# ðŸŽ¯ Create Procfile with BP_START command
log_step "Creating Procfile"

# Check if BP_START is a script name or a direct command
if [[ "$BP_START" != *" "* ]] && [ -f "package.json" ] && grep -q "\"$BP_START\"" package.json; then
  # It's a script name, extract the actual command from package.json
  log_info "BP_START '$BP_START' is a package.json script"
  ACTUAL_COMMAND=$(cat package.json | bun -e "const p=JSON.parse(await Bun.stdin.text()); console.log(p.scripts?.['$BP_START'] || '$BP_START')" 2>/dev/null || echo "$BP_START")
  echo "web: $ACTUAL_COMMAND" > Procfile
  log_success "Created Procfile with: web: $ACTUAL_COMMAND (from script '$BP_START')"
else
  # It's a direct command
  echo "web: $BP_START" > Procfile
  log_success "Created Procfile with: web: $BP_START"
fi

# ðŸ§¹ Cleanup to reduce slug size
if is_true "$BP_CLEAN"; then
  log_step "Cleaning up to reduce slug size"
  
  # Remove source directories
  rm -rf apis web desktop packages utils tools apps
  rm -rf node_modules/.cache
  rm -rf .nx .cache tmp
  
  # Remove build artifacts
  rm -rf *.md *.lock *.lockb tsconfig*.json nx.json .git*
  
  SLUG_SIZE=$(du -sh . | cut -f1)
  log_success "Cleanup complete - final slug size: $SLUG_SIZE"
else
  log_info "Skipping cleanup (BP_CLEAN=false)"
fi

# ðŸ“Š Final summary
log_header "Build Summary"
log_success "Project: $BP_BUILD"
log_success "Built from: $PROJECT_PATH"
log_success "Start command: $BP_START"
log_success "Slug size: $(du -sh . | cut -f1)"
if is_true "$BP_NODE"; then
  log_success "Runtime: Bun $(bun --version) + Node $(node --version)"
else
  log_success "Runtime: Bun $(bun --version)"
fi

log_info "Your app will start with: $BP_START"
log_info "To change: heroku config:set BP_START='new-command'"

log_header "âœ… Build Complete - Ready for deployment!"